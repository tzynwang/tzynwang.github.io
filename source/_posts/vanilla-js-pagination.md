---
title: 自主練習「純手工pagination」技術記錄
date: 2021-04-15 19:29:46
categories:
- JavaScript
tags:
---

## 總結
練習為pagination加上JavaScript，使其可與使用者互動。
- 使用到的技術
  - DOM Traversing: parent, siblings
- 新學習到的概念
  - `pointer-events: none`
  - `parseInt()`與`Number()`的差異

## 成品
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="Charlie7779" data-slug-hash="yLgEJyr" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="pagination practice">
  <span>See the Pen <a href="https://codepen.io/Charlie7779/pen/yLgEJyr">
  pagination practice</a> by Charlie (<a href="https://codepen.io/Charlie7779">@Charlie7779</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

## 環境
```
Google Chrome: 90.0.4430.72 (Official Build) (64-bit)
Bootstrap: 5.0.0-beta3
os: Windows_NT 10.0.18363 win32 x64
```

## 流程
1. 使用[Bootstrap: Pagination](https://getbootstrap.com/docs/5.0/components/pagination/)的HTML原始碼，並移除不需要的部分
  - `aria-label`在練習中用不到，移除
  - `<li>`使用JavaScript產生，全部移除；加上備註，提示內容會由JavaScript處理
  - 整理完畢後，HTML部分的原始碼如下
  ```HTML
  <nav>
    <ul class="pagination justify-content-center" id="pagination">
      <!-- generated by JavaScript -->
    </ul>
  </nav>
  ```
1. 粗略分解任務：「使用者與pagination互動時，會發生什麼事情？」
  - 點選previous或next來前進、後退
  - 直接點選頁數來進行換頁
  - 抵達頁數的「頭」或「尾」後，繼續點選previous或next不會有任何事情發生
  - 換頁後，畫面須呈現相對應的內容
1. 將以上任務流程精緻化
  - 「點選previous或next來前進、後退」與「直接點選頁數來進行換頁」
    - 需監聽滑鼠點擊事件
    - 需判定滑鼠點擊的目標是previous、next或頁數
    - 要判定使用者點擊pagination後會在「哪一頁」
  - previous或next與頁數頭尾互動事件：
    - 使用者抵達首尾頁後，點擊previous或next不可繼續前進或後退
    - 使用者不在首尾頁時，previous或next應恢復功能
  - 換頁後，畫面須呈現相對應的內容
    - 要判定使用者點擊pagination後會在「哪一頁」
1. 使用程式碼滿足以上列出的需求

## JavaScript原始碼
### 全域變數
<script src="https://gist.github.com/tzynwang/f7fa03af729005ba9c3f1c6f470fd0f0.js"></script>

- `pageCount`：儲存總頁數的變數；除了直接賦值外，也可承接其他function回傳的值。比如在ALPHA Camp的練習情境中，`pageCount`可承接「電影總數（80筆）除以每一頁的電影數量（12筆）後無條件進位」此情境的總頁數數量（pagination應展示7頁）
- `initialPage`：畫面載入時，預設顯示的頁面；在本練習中預設顯示第1頁

### `dynamicallyGeneratePage (page)`
目的：根據傳入的總頁數（page）數量來產生pagination；比如傳入8，即要產生8頁的pagination
<script src="https://gist.github.com/tzynwang/cdc5647b1c895d53dbf376fac78b8905.js"></script>

- 第3行：加入Previous按鈕。而因為起始頁是第一頁（`initialPage`設定為1），故Previous按鈕預設是不會有任何功能的（不可繼續前進），所以在`<li>`加上`.disabled`
- 第4-8行：加入頁數，頁數根據傳入`dynamicallyGeneratePage()`的參數決定。並將`initialPage`加上`.active`，標記其為起始頁
- 第9行：加入Next按鈕
- 第10行：將第三行到第九行的內容放進`pagination`（`document.querySelector('#pagination')`）中
- 第11行：設定`display`（`document.querySelector('#display')`）內容
- 關於`data-page`：使用[dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/dataset)為每一個`<a>`元素加上`data-page`，讀取`data-page`的值即可判定該`<a>`為Previous、Next或頁數按鈕

### `innerHTMLContent (page)`
目的：根據傳入的頁數，產生對應的畫面內容
<script src="https://gist.github.com/tzynwang/50676fa823ed5435fa251833e215d88a.js"></script>

- 第4行：根據傳入的`page`來產生相對應的頁數
- 第5行：使用[Lorem Picsum](https://picsum.photos/)透過id[指定特定圖片](https://picsum.photos/images)的服務，根據傳入的`page`來產生圖片，達成換頁換圖的效果
- 第7行：`innerHTMLContent()`回傳的值可直接賦予`innerHTML`

### `paginationStatusUpdate (event)`
目的：根據使用者點擊的目標，更新pagination的狀態；並呼叫`innerHTMLContent()`來修改畫面內容
<script src="https://gist.github.com/tzynwang/ae875b2df97e736f08edd53093dcd13d.js"></script>

- 第2行：`const pageData = event.target.dataset.page`
  - 點擊事件發生後，抓取「被點擊的目標」其`data-page`的值，每一個`<a>`元素的`data-page`是透過`dynamicallyGeneratePage()`產生的
  - 點擊到Previous時，`pageData`為`p`；點擊到Next時，`pageData`為`n`
  - 點擊到處於`disabled`狀態的Previous與Next時，`pageData`為`undefined`，理由如下：
    - 參考Bootstrap 5.0.0-beta3的原始碼可得知`.page-item.disabled .page-link`的設定為
    ```CSS
    .page-item.disabled .page-link {
      color: #6c757d;
      pointer-events: none;
      background-color: #fff;
      border-color: #dee2e6;
    }
    ```
    注意這段選取器的作用對象是.page-item.disabled下的「.page-link」，而HTML結構如下
    ```HTML
    <li class="page-item disabled">
      <a class="page-link" href="#" data-page="p">Previous</a>
    </li>
    ```
    所以`pointer-events: none;`實際作用的對象是`<a>`
    - 根據[MDN的規格](https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events#values)，`pointer-events`設定為`none`時，該元素（在本練習中為`<a>`）無法成為滑鼠游標點擊事件的目標（原文：The element is never the target of pointer events.）
    - 所以在Previous與Next處於`disabled`時，`<a>`不會成為滑鼠游標點擊事件的目標；在這樣的情況下，游標點擊事件會觸發的目標會變成該元素的親元素（在本練習中為`<li>`）（原文：In these circumstances, pointer events will trigger event listeners on this parent element as appropriate on their way to/from the descendant during the event capture/bubble phases.）
    - 而`<li>`沒有設定`pageData`，所以當我想要取`<li>`的`pageData`的值的時候，我會得到`undefined`
  - 結論：`pageData`的值有以下可能性
    - `undefined`：代表Previous與Next處於`disabled`的狀態
    - `p`或`n`：當Previous與Next不處於`disabled`時，點擊Previous或Next會讓`pageData`的值為`p`或`n`
    - 頁數的數字：當使用者點擊頁數時，`pageData`的值就是該頁數的數字，但資料型態會是`String`
- 第3行：`const activePage = document.querySelector('#pagination li.active')`
  - 取「處於`active`狀態」的`<li>`
- 第4行：`const activePageNumber = activePage.firstElementChild.dataset.page`
  - 會取得點擊事件發生時，處於`active`狀態的`<li>`其子元素`<a>`的`data-page`資料
  - 舉例：若目前`.active`的是第1頁，而我點了第4頁，`activePageNumber`的值會是1
- 第5-6行：固定取得Previous`<li>`與Next`<li>`，因為`.disabled`與`.active`是在`<li>`上操作的
- 第8行開始的`switch (pageData)`：
  - `case undefined`：代表使用者在Previous或Next處於`disabled`時點擊這兩個按鈕，這時不應該再繼續執行翻頁的動作，故直接`return`，什麼事都不發生
  - `case "p"`：
    - 代表使用者點擊Previous時，此按鈕不處於`disabled`狀態，所以Previous應該帶領使用者前往上一頁
    - 第12行代表「點擊Previous時從最後一頁離開」，這時Next就不應繼續處於`disabled`狀態，故需移除`.disabled`
    - 第14-16行：代表「點擊Previous時正在通過第二頁」，而從第二頁往前移動後，就會位在第一頁，位在第一頁後就不可繼續往前翻頁了，所以Previous要加上`.disabled`，進入`disabled`狀態
    - 第18-19行：若點擊Previous時，Previous不符合第12-16行列出的條件，就進行「移除目前處於`active`頁數的`.active`，並為前一頁加上`.active`」
    - 第20行：因為移動到前一頁了，所以`display`的內容也要更新，換成前一頁（activePageNumber - 1）的內容
  - `case "n"`：換頁的邏輯與Previous相反
    - 第23行代表「點擊Next時從第一頁離開」，這時Previous就不應繼續處於`disabled`狀態，故需移除`.disabled`
    - 第25-27行：代表「點擊Next時正在通過倒數第二頁」，而從倒數第二頁往後移動後，就會位在最末頁，位在最末頁後就不可繼續往後翻頁了，所以Next要加上`.disabled`，進入`disabled`狀態
    - 第29-31行：若點擊Next時，Next不符合第23-27行列出的條件，就進行「移除目前處於`active`頁數的`.active`，並為下一頁加上`.active`」
  - `default`：代表`pageData`不屬於上述任何一種狀態，亦即使用者直接點選了頁數
    - 第34行：移除`activePage`的`active`狀態
    - 第35行：為`event.target`（被滑鼠點選到）的`parentElement`（即是`<li>`）加上`active`狀態
    - 第36行：更新`display`的內容
    - 第38-40行：使用者點選到最末頁時，Next要變為`disabled`狀態
    - 第42-44行：使用者點選到第一頁時，Previous要變為`disabled`狀態

## bonus track：`parseInt()`與`Number()`的差別
- 在過去的專案與練習中，習慣直接使用`parseInt()`來將字串解析（parsing）為數字，本次改為使用`Number()`來將字串型變（type converting）為數字
- 雖然這兩者都可以回傳我需要的資料，但好奇這其中是否有差異，而經過搜尋後得知：
- `Number()`做的事：convert
  - [Annotated ECMAScript 5.1](http://es5.github.io/#x15.7.1): When `Number` is called as a **function** (rather than as a constructor), it performs a **type conversion**.
  - [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number): Values of **other types** can **be converted to numbers** using the `Number()` function.
- `parseInt()`做的事：parse，而非convert
  - [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt): The `Number.parseInt()` method **parses** a **string** argument and returns an integer of the specified radix or base.
- 結論：雖然都可以透過傳入`String`得到`Number`，但`parseInt()`與`Number()`處理的手法並不一樣


## 參考文件
- [JavaScript DOM Traversing](https://www.javascripttutorial.net/dom/traversing/)
  - [Get Siblings of an Element](https://www.javascripttutorial.net/dom/traversing/get-siblings-of-an-element/)
  - [Get the Parent of an Element](https://www.javascripttutorial.net/dom/traversing/get-the-parent-of-an-element/)
- [MDN: pointer-events](https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events#values)
- [Number() vs parseInt()](https://thisthat.dev/number-constructor-vs-parse-int/)
- [What is the difference between parseInt() and Number()?](https://stackoverflow.com/questions/4090518/what-is-the-difference-between-parseint-and-number)